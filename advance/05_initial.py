class Puppy:

    name="" #멤버 변수(필드) : class 안에서 사용 가능한 변수
    goal=""

    def __init__(self,name, goal): # 생성자 : 객체화시 호출되는 함수
        # 받아온 name 과 goal 은 이 생성자를 벗어날수 없다.(생성자의 쓰임이 다하면 함께 없어진다.)
        # 그래서 클래스(객체) 멤버 에다가 넣어줘야, 객체가 살아있는 동안 사용이 가능 하다.
        # 그런데  name = name 형태로는 어떤것이 객체의 멤버인지 알 수 없다.
        # 그래서 멤버인 녀석은 self 를 이용하여 표시해 준다.
        self.name=name
        self.goal=goal

puppy = Puppy("멍멍이","집지키기")
print(f'이름:{puppy.name}/목적:{puppy.goal}')

# Puppy 설계도임.
# name과 goal이라는 특성을 줄건데 특성을 지정하지않고 외부에서 들어온 걸 토대로 줄거임.
# 초기설정은 특성이 들어오는대로 줄거임. 그리고 난 일회성임.
# 해당 특성이 들어오면 나는 일회성이기 때문에 만들어지는 순간 사라짐. 그래서 들어온 특성을 self 도구를 사용해 기록해서 붙일거임.
# 물건이 나오면 그 과정을 puppy라고 부를거임.
# 만들어졌을 때, 기록한 특성1과 특성2를 출력해

# Puppy라는 클래스를 생성했다. (원본을 통해 init을 통해 복사본을 만든다.)
# 그리고 함수 init 생성자로 외부에서 받아온 name과 goal로 설정된다.
# init 생성자 함수는 한 번 돌면 사라지는 특성이 있기때문에 받아온 name과 goal은 사라진다. 그렇기 때문에 받아온 name과 goal은 self를 사용해 받아온 객체를 기록한다.
# 이 모든 과정을 puppy라고 설정한다.
# 이후 Puppy 클래스의 기록된 객체 속성을 출력한다. (Puppy.name → Puppy의 name 속성 출력 등..)